import{a7 as w,a8 as T}from"./builtins-C5GxhwDd.js";class L{constructor(r,l){this.vertex=new w(r,l)}get name(){return this.vertex.name}get statements(){return this.vertex.statements}toGLSL(){return this.vertex.toGLSL(2)}toWGSL(r){const g=r.varyings,i=(r.bufferMode??"INTERLEAVED_ATTRIBS")==="SEPARATE_ATTRIBS";return T({language:"wgsl",stage:"compute",version:1},()=>{var v,h,m,y;const e=[];this.vertex.executeBodyIfNeeded();const n=this.vertex.getAnalyzedDependencies();this.vertex.allocateLocations(n.attributes);const d=globalThis.Array.from(n.attributes),u=g.includes("gl_Position"),_=g.filter(t=>t!=="gl_Position"),b=globalThis.Array.from(n.varyings),f=_.map(t=>{const o=b.find(c=>c.name===t);if(!o)throw new Error(`[TSL] Varying '${t}' not found in shader dependencies`);return o}),x=globalThis.Array.from(n.shaderFuncs);if(!i){e.push("struct VertexOutput {"),u&&e.push("    gl_Position: vec4<f32>,");for(const t of f){const o=((v=t.value)==null?void 0:v.wgslType)??"vec4<f32>";e.push(`    ${t.name}: ${o},`)}e.push("}"),e.push("")}const S=new Set(n.structUniforms.map(t=>t.uniform.name));let s=0;for(const t of n.uniforms)if(!S.has(t.name)){const o=t.getEffectiveGroup();e.push(`@group(${o}) @binding(${s}) var<uniform> ${t.name}: ${((h=t.value)==null?void 0:h.wgslType)??"mat4x4<f32>"};`),s++}for(const t of n.structUniforms){const o=t.uniform.getEffectiveGroup();e.push(t.structDef.toWGSLUniform(t.instanceName,o,s)),s++}for(const t of d){const o=((m=t.value)==null?void 0:m.wgslType)??"vec4<f32>";e.push(`@group(0) @binding(${s}) var<storage, read> inputData_${t.name}: array<${o}>;`),s++}if(i){u&&(e.push(`@group(0) @binding(${s}) var<storage, read_write> outputData_gl_Position: array<vec4<f32>>;`),s++);for(const t of f){const o=((y=t.value)==null?void 0:y.wgslType)??"vec4<f32>";e.push(`@group(0) @binding(${s}) var<storage, read_write> outputData_${t.name}: array<${o}>;`),s++}}else e.push(`@group(0) @binding(${s}) var<storage, read_write> outputData: array<VertexOutput>;`),s++;e.push("");for(const t of x)e.push(t.toWGSL()),e.push("");e.push("@compute @workgroup_size(64)"),e.push(`fn ${this.name}(@builtin(global_invocation_id) global_id: vec3<u32>) {`),e.push("    let idx = global_id.x;"),i||e.push("    var output: VertexOutput;"),e.push("");for(const t of d)if(t.value){const o=t.name;t.value.toWGSL=()=>`inputData_${o}[idx]`}for(const t of f)if(t.value){const o=t.name;i?t.value.toWGSL=()=>`outputData_${o}[idx]`:t.value.toWGSL=()=>`output.${o}`}const a=globalThis.Array.from(n.builtins).find(t=>t.isPosition);a&&a.value&&(u?i?a.value.toWGSL=()=>"outputData_gl_Position[idx]":a.value.toWGSL=()=>"output.gl_Position":a.value.toWGSL=()=>"/* gl_Position ignored in compute shader */");for(const t of this.statements){const o=t.toWGSL();if(o.trim()===""||o.includes("precision")||t._isAutoVarDeclaration||t._isAutoReturn||t._isAutoDepthConvert)continue;const c=o.split(`
`);for(const $ of c)e.push(`    ${$}`)}return i||(e.push(""),e.push("    outputData[idx] = output;")),e.push("}"),e.join(`
`)+`
`})}}function D(p,r){return new L(p,r)}export{D as t};
